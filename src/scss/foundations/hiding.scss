////
/// Hiding Rules define all rules for hiding content based on device width.
/// @group HIDING
////

@use "../lib";
@use "breakpoints";

/// Hide an element from `$fromBreakpoint` to `$untilBreakpoint` value.
/// Outside the indicated breakpoints the element will have the assigned display value.
///
/// @param {String} $fromBreakpoint - Name of start breakpoint
/// @param {String} $untilBreakpoint - Name of end breakpoint
/// @throw {Error}
///
/// @example scss - Hide Mixin
///  // Hide the element for every breakpoints
///  .element {
///     @include hide();
///  }
///
///  // Hide element from breakpoint medium
///  .element {
///     display: grid;
///     @include hide(medium);
///  }
///
///  // Hide element between breakpoint small and large
///  .element {
///     display: grid;
///     @include hide(small, large);
///  }
/// @access public
@mixin hide($fromBreakpoint: base, $untilBreakpoint: null) {
  @if(lib.isNotNull($untilBreakpoint) and breakpoints.isGreaterOrEqualTo($fromBreakpoint, $untilBreakpoint)) {
    @error "You cannot use a `$untilBreakpoint` value smaller or equal than `$fromBreakpoint` value";
  }

  @include breakpoints.mq($fromBreakpoint, $untilBreakpoint) {
    display: none;
  }
}

/// Create atom classes for hiding
///
/// @access public
@mixin createAtoms() {
  $breakpointMap: breakpoints.breakpoints();
  @each $breakpointName, $breakpointValue in $breakpointMap {
    $append: if(breakpoints.isBase($breakpointName), "", "-from-#{$breakpointName}");
    .hide#{$append} {
      @include hide($breakpointName);
    }
    @if(not breakpoints.isBase($breakpointName)) {
      $nextBreakpoint: lib.getNextElementKey($breakpointMap, $breakpointName $breakpointValue);
      .hide-on-#{$breakpointName} {
        @include hide($breakpointName, $nextBreakpoint);
      }
    }
  }
}